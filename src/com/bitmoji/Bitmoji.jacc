// JACC Implementation of the Bitmoji Parser

//////////////////////////////////////////
// Directives
//////////////////////////////////////////

%package com.bitmoji
%class Bitmoji
%interface BitmojiTokens
%next yynext()
%get lexer.getToken()
%semantic Object : lexer.getValue()

// Conditionals
%token EQUALS NOT_EQUALS LESS_THAN GREATER_THAN LESS_THAN_OR_EQUAL GREATER_THAN_OR_EQUAL
// Arithmetic Operators
%token ADD SUBTRACT MULTIPLY DIVIDE EXPONENT
// Grouping
%token LEFT_BRACKET RIGHT_BRACKET LEFT_PARENTHESIS RIGHT_PARENTHESIS
// Assignment
%token INTEGER_DECL REAL_DECL STRING_DECL ARRAY_DECL ASSIGN
// Control
%token START_WHILE END_WHILE IF ELIF ELSE START_THEN END_THEN
// Functions
%token FUNCTION_DEF START_FUNCTION_STATEMENTS END_FUNCTION_STATEMENTS RETURN PARAMETER_COMMA
// Literals
%token REAL_LITERAL INT_LITERAL STRING_LITERAL
// IO
%token INPUT OUTPUT
// Other
%token ID START_PROGRAM END_PROGRAM
%left SUBTRACT
%right ASSIGN

%%
//////////////////////////////////////////
// Grammar Rules
//////////////////////////////////////////
program : START_PROGRAM stmnt_list END_PROGRAM
                        {

                        }
                        ;

stmnt_list : stmnt_list statement
			| statement
			;

statement : assignment 
		  | while_statement
		  | input
		  | output
		  | if_statement
		  | function_call
		  | function_def //Does this go in the program NT or does it go outside program NT?
		  ;
		  
		  
/*		  
array_decl : ARRAY_DECL array_type ID //Dynamically-sized array.
		  ;

int_decl : INTEGER_DECL ID
		  ;

real_decl : REAL_DECL ID
		  ;

string_decl : STRING_DECL ID
		  ;
*/


ref : ID LEFT_BRACKET expr RIGHT_BRACKET
	| ID
	;

array_type : INTEGER_DECL
		   | REAL_DECL
		   | STRING_DECL
		   ;
		   
expr : expr ADD term
	 | expr SUBTRACT term
	 | term
	 | function_call
	 ;
	 
term : term MULTIPLY factor
	 | term DIVIDE factor
	 | factor
	 ;
	 
factor : factor EXPONENT exp
	   | exp
	   ;
	   
exp : LEFT_PARENTHESIS expr RIGHT_PARENTHESIS
	| ref
	| REAL_LITERAL
	| INT_LITERAL
	;
	
assignment : ID ASSIGN expr
		   ;

while_statement : START_WHILE equality stmnt_list END_WHILE
				;
				
input : INPUT ref
	  ;

output : OUTPUT expr
	   | OUTPUT STRING_LITERAL
	   ;

conditional : if_statement
			| if_statement elif_statement
			| if_statement else_statement
			| if_statement elif_statement else_statement
			;

if_statement : IF LEFT_PARENTHESIS equality RIGHT_PARENTHESIS START_THEN stmnt_list END_THEN
			 ;

elif_statement : ELIF LEFT_PARENTHESIS equality RIGHT_PARENTHESIS START_THEN stmnt_list END_THEN
			   | ELIF LEFT_PARENTHESIS equality RIGHT_PARENTHESIS START_THEN stmnt_list END_THEN elif_statement
			   ;

else_statement : ELSE START_THEN stmnt_list END_THEN
			   ;

function_call : ID LEFT_PARENTHESIS ref_list RIGHT_PARENTHESIS
			  ;
			  
ref_list : ref_list PARAMETER_COMMA ref
		 | ref
		 ;

function_def : FUNCTION_DEF ID LEFT_PARENTHESIS parameter_list RIGHT_PARENTHESIS START_FUNCTION_STATEMENTS stmnt_list RETURN LEFT_PARENTHESIS expr RIGHT_PARENTHESIS END_FUNCTION_STATEMENTS
			 ;
		   
parameter_list : parameter_list PARAMETER_COMMA ID
			   | ID
			   ;
			   

equality : equality EQUALS relational
		 | equality NOT_EQUALS relational
		 | relational
		 ;
		 
relational : relational GREATER_THAN expr
		   | relational GREATER_THAN_OR_EQUAL expr
		   | relational LESS_THAN expr
		   | relational LESS_THAN_OR_EQUAL expr
		   | expr
		   ;


%%

//////////////////////////////////////////
// Extra Code
//////////////////////////////////////////

    private BitmojiLexer lexer;
    private int token;
    private Object yylvalue;
    private BitmojiParseTree tree;
    private BitmojiParseTree.ProgramNode program;

    public int yynext() {
        lexer.next();
        token = lexer.getToken();
        yylvalue = lexer.getValue();

        return token;
    }

    public void yyerror(String msg) {
        lexer.printError("ERROR: " + msg);
    }

    public Bitmoji(java.io.InputStream in) {
        lexer = new BitmojiLexer(in);
        tree = new BitmojiParseTree(this);
    }


    public BitmojiParseTree.ProgramNode getProgram() {
        return program;
    }


    public static void main(String [] args) {
        boolean interpret = true;
        boolean printTree = false;
        boolean compile = false;
        String filename="";

        //process command line
        for(int i=0; i<args.length; i++) {
            if(args[i].equals("-c")) {
                interpret = false;
                compile = true;
            } else if(args[i].equals("-t")) {
                printTree = true;
            } else {
                filename = args[i];
            }
        }

        try {
            Bitmoji parser = new Bitmoji(new java.io.FileInputStream(filename));
            parser.yynext();
            parser.parse();
 
            //print the tree
            if(printTree) {
                parser.getProgram().print("");
            }

            //interpret the code
            if(interpret) {
                parser.getProgram().evaluate();
            }

            //compile the code to c
            if(compile) {
                java.io.FileOutputStream file = new java.io.FileOutputStream(filename.split("\\.")[0] + ".c");
                file.write(parser.getProgram().generate().getBytes());
                file.close();
            }

        } catch(java.io.FileNotFoundException e) {
            System.err.println("Could not open file.");
        } catch(java.io.IOException e) {
            System.err.println("File Write Error");
        }
    }